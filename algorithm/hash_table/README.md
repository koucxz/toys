# 哈希表 / 散列

优点：
- 快速插入，删除和取用
- 比树编码容易，取用快

缺点：
- 查找较慢（如寻找最大值最小值，可用二叉查找树实现）

#### 哈希表概念
- 哈希化：将大数字转化成数组范围内下标的过程；
- 哈希函数：将要存储的内容转化成大数字，把存储内容进行哈希化的代码实现；
- 哈希表：对上述方法和数据插入的数组进行整个结构的封装，理解为一种数据类型

#### 碰撞处理
哈希化过后的下标依然可能重复，称之为哈希碰撞

1. 开链法（链地址法）：

每个数组单元中存储的不再是单个数据，而是一条链条，这条链条常使用的数据结构为数组或链表

2. 开放寻址法：
寻找空白的单元格来放置发生碰撞的数据项

##### 线性探测法
当发生碰撞时，线性探测法检查散列表中的下一个位置是否为空。如果为空，就将数据存入该位置；如果不为空，则继续检查下一个位置，直到找到一个空的位置为止。该技术是基于这样一个事实：每个散列表都会有很多空的单元格，可以使用它们来存储数据。

线性探测法问题：
- 线性探测存在一个比较严重的问题，就是聚集；
如哈希表中还没插入任何元素时，插入23、24、25、26、27，这就意味着下标值为3、4、5、6、7的位置都放置了数据，这种一连串填充单元就称为聚集；

- 聚集会影响哈希表的性能，无论是插入/查询/删除都会影响；

- 如果之前的数据是连续插入的，那么新插入的一个数据可能需要探测很长的距离。二次探测法可以解决该问题。

##### 二次探测法

对步长进行了优化，比如从下标值x开始探测：x+1<sup>2</sup>、x+2<sup>2</sup>、x+3<sup>2</sup> 。这样一次性探测比较长的距离，避免了数据聚集带来的影响。

二次探测法问题：
- 当插入数据分布性较大的一组数据时，比如：13-163-63-3-213，这种情况会造成步长不一的一种聚集（虽然这种情况出现的概率较线性探测的聚集要小），同样会影响性能。
- 产生一个很长的数组，占用内存

##### 再哈希化
背景
- 产生一种依赖关键字(数据)的探测序列，而不是每个关键字探测步长都一样；
- 不同的关键字即使映射到相同的数组下标，也可以使用不同的探测序列；
实现：
把关键字用另一个哈希函数，再做一次哈希化，用这次哈希化的结果作为该关键字的步长；
- 第一个和第一个哈希函数不能相同；
- 探测步长不能输出为0

#### 哈希化效率
哈希表中执行插入和搜索操作效率是非常高的。
- 如果没有发生冲突，那么效率就会更高；
- 如果发生冲突，存取时间就依赖后来的探测长度；
- 平均探测长度以及平均存取时间，取决于`装填因子`，随着装填因子变大，探测长度会越来越长。

##### 装填因子
哈希表中已经包含的数据项和整个哈希表长度的比值（装填因子 = 总数据项 / 哈希表长度）；

开链法随着装填因子的增加，平均探测长度呈线性增长，较为平缓。在开发中使用链地址法较多，比如Java中的HashMap中使用的就是链地址法。

##### 扩容与缩容
开链法实现的哈希表可以无限制地插入新数据，随着数据量的增多，一个bucket数组（链表）就会越来越长，这就会造成哈希表效率的降低

通常情况下当装填因子laodFactor > 0.75时，对哈希表进行扩容。
当装填因子laodFactor < 0.25时，对哈希表容量进行压缩。

#### simple.js
哈希表的简单实现，未处理碰撞

#### index.js
哈希表的开链法完整实现，根据装填因子扩容缩容。
